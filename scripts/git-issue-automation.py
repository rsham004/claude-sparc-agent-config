#!/usr/bin/env python3
"""
SPARC Framework - Git Issue Automation System
Implements automatic Git issue creation and management for framework violations
"""

import subprocess
import json
import sys
import os
from datetime import datetime
from typing import Dict, List, Optional
from dataclasses import dataclass

@dataclass
class FrameworkViolation:
    """Represents a SPARC framework violation that needs Git issue tracking"""
    violation_type: str
    severity: str  # critical, high, medium, low
    phase: str     # design, implementation, validation
    agent: str     # which agent is affected
    description: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    resolution_steps: List[str] = None

class SPARCGitIssueManager:
    """Manages automated Git issue creation and tracking for SPARC framework violations"""
    
    def __init__(self, project_name: str = ""):
        self.project_name = project_name
        self.issue_templates = self._load_issue_templates()
        
    def _load_issue_templates(self) -> Dict[str, str]:
        """Load issue templates for different violation types"""
        return {
            "design_violation": """# SPARC Framework Violation - Design Phase

**Phase:** Design
**Agent:** {agent}
**Severity:** {severity}
**Violation Type:** {violation_type}

## Problem Description
{description}

## Current State
- [ ] Problem identified
- [ ] Investigation started
- [ ] Solution proposed
- [ ] Fix implemented
- [ ] Validation passed

## Resolution Requirements
{resolution_steps}

## Dependencies
- Blocked by: None
- Blocks: {blocked_agents}

## Framework Impact
- [ ] Affects subsequent agents
- [ ] Breaks workflow sequence
- [ ] Violates SPARC methodology
- [ ] Impacts quality gates

**Created:** {timestamp}
**Auto-generated by SPARC Framework**
""",
            
            "tdd_violation": """# TDD-Guard Violation - Test-Driven Development

**Phase:** Implementation
**Severity:** {severity}
**File:** {file_path}
**Line:** {line_number}

## TDD Violation Description
{description}

## TDD Compliance Status
- [ ] RED: Failing tests written
- [ ] GREEN: Minimal implementation passes tests
- [ ] REFACTOR: Code quality improved
- [ ] VALIDATION: All tests passing

## Resolution Steps
{resolution_steps}

## Quality Impact
- [ ] Test coverage below 90%
- [ ] Implementation without tests
- [ ] Over-implementation detected
- [ ] Code quality degradation

**Created:** {timestamp}
**Auto-generated by TDD-Guard**
""",
            
            "technology_violation": """# Technology Compliance Violation

**Phase:** {phase}
**Agent:** {agent}
**Severity:** {severity}

## Technology Violation
{description}

## Compliance Check
- [ ] technology-lock.json validated
- [ ] Unauthorized import removed
- [ ] Approved alternative identified
- [ ] Solution Architect approval obtained

## Resolution Requirements
{resolution_steps}

## Approved Alternatives
[To be filled by Solution Architect]

**Created:** {timestamp}
**Auto-generated by Technology Lock Enforcer**
""",
            
            "quality_gate_failure": """# Quality Gate Failure

**Phase:** {phase}
**Severity:** {severity}
**Failed Checks:** {failed_checks}

## Quality Gate Failures
{description}

## Quality Status
- [ ] Linting issues resolved
- [ ] Type checking passed
- [ ] Test coverage restored
- [ ] Performance metrics met

## Failed Checks Details
{resolution_steps}

## Commit Blocker
This issue blocks all commits until resolved.

**Created:** {timestamp}
**Auto-generated by Quality Gate System**
"""
        }
    
    def create_violation_issue(self, violation: FrameworkViolation) -> Optional[str]:
        """Create Git issue for framework violation"""
        try:
            # Generate issue title
            title = self._generate_issue_title(violation)
            
            # Generate issue body
            body = self._generate_issue_body(violation)
            
            # Generate labels
            labels = self._generate_labels(violation)
            
            # Create issue using GitHub CLI
            cmd = [
                "gh", "issue", "create",
                "--title", title,
                "--body", body,
                "--label", ",".join(labels)
            ]
            
            # Add assignee if in implementation phase
            if violation.phase == "implementation":
                cmd.extend(["--assignee", "@me"])
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                issue_url = result.stdout.strip()
                print(f"✅ Created issue: {issue_url}")
                return issue_url
            else:
                print(f"❌ Failed to create issue: {result.stderr}")
                return None
                
        except Exception as e:
            print(f"❌ Error creating issue: {e}")
            return None
    
    def _generate_issue_title(self, violation: FrameworkViolation) -> str:
        """Generate appropriate issue title based on violation type"""
        severity_emoji = {
            "critical": "🚨",
            "high": "❗",
            "medium": "⚠️",
            "low": "📝"
        }
        
        phase_prefix = {
            "design": "DESIGN",
            "implementation": "TDD",
            "validation": "QUALITY"
        }
        
        emoji = severity_emoji.get(violation.severity, "📝")
        prefix = phase_prefix.get(violation.phase, "FRAMEWORK")
        
        return f"{emoji} {prefix} VIOLATION: {violation.description[:60]}..."
    
    def _generate_issue_body(self, violation: FrameworkViolation) -> str:
        """Generate issue body from template"""
        template_key = self._get_template_key(violation)
        template = self.issue_templates.get(template_key, self.issue_templates["design_violation"])
        
        resolution_steps = "\n".join([f"- {step}" for step in (violation.resolution_steps or [])])
        blocked_agents = self._get_blocked_agents(violation)
        failed_checks = getattr(violation, 'failed_checks', '')
        
        return template.format(
            agent=violation.agent,
            severity=violation.severity.upper(),
            violation_type=violation.violation_type,
            description=violation.description,
            resolution_steps=resolution_steps or "- Review violation and implement fix",
            blocked_agents=blocked_agents,
            phase=violation.phase.title(),
            file_path=violation.file_path or "N/A",
            line_number=violation.line_number or "N/A",
            failed_checks=failed_checks,
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")
        )
    
    def _get_template_key(self, violation: FrameworkViolation) -> str:
        """Determine which template to use based on violation type"""
        if "tdd" in violation.violation_type.lower():
            return "tdd_violation"
        elif "technology" in violation.violation_type.lower():
            return "technology_violation"
        elif "quality" in violation.violation_type.lower():
            return "quality_gate_failure"
        else:
            return "design_violation"
    
    def _generate_labels(self, violation: FrameworkViolation) -> List[str]:
        """Generate appropriate labels for the issue"""
        labels = [
            "sparc-framework",
            violation.phase,
            violation.severity,
            f"agent-{violation.agent.lower().replace(' ', '-')}"
        ]
        
        # Add specific labels based on violation type
        if "tdd" in violation.violation_type.lower():
            labels.extend(["tdd-guard", "testing"])
        elif "technology" in violation.violation_type.lower():
            labels.extend(["technology-lock", "compliance"])
        elif "quality" in violation.violation_type.lower():
            labels.extend(["quality-gate", "blocker"])
        
        # Add blocker label for critical/high severity
        if violation.severity in ["critical", "high"]:
            labels.append("blocker")
        
        return labels
    
    def _get_blocked_agents(self, violation: FrameworkViolation) -> str:
        """Determine which agents are blocked by this violation"""
        agent_sequence = [
            "product-manager", "solution-architect", "ux-designer", 
            "visual-style-specialist", "data-architect", "senior-api-developer", 
            "project-planner", "senior-coder", "tdd-guard-tester"
        ]
        
        try:
            current_index = agent_sequence.index(violation.agent.lower().replace(" ", "-"))
            blocked = agent_sequence[current_index + 1:]
            return ", ".join(blocked)
        except ValueError:
            return "All subsequent agents"
    
    def check_open_blockers(self) -> List[Dict]:
        """Check for open blocking issues"""
        try:
            cmd = ["gh", "issue", "list", "--label", "blocker", "--state", "open", "--json", "number,title,labels"]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                return json.loads(result.stdout)
            else:
                return []
        except Exception:
            return []
    
    def validate_phase_completion(self, phase: str) -> bool:
        """Validate that phase can be completed (no open blockers)"""
        blockers = self.check_open_blockers()
        phase_blockers = [
            issue for issue in blockers 
            if any(label["name"] == phase for label in issue["labels"])
        ]
        
        if phase_blockers:
            print(f"❌ Cannot complete {phase} phase - {len(phase_blockers)} blocking issues:")
            for issue in phase_blockers:
                print(f"   • Issue #{issue['number']}: {issue['title']}")
            return False
        
        return True
    
    def update_issue_progress(self, issue_number: int, progress_comment: str):
        """Update issue with progress comment"""
        try:
            cmd = ["gh", "issue", "comment", str(issue_number), "--body", progress_comment]
            subprocess.run(cmd, check=True)
            print(f"✅ Updated issue #{issue_number} with progress")
        except subprocess.CalledProcessError:
            print(f"❌ Failed to update issue #{issue_number}")
    
    def close_resolved_issue(self, issue_number: int, resolution_comment: str):
        """Close issue with resolution comment"""
        try:
            # Add resolution comment
            self.update_issue_progress(issue_number, f"✅ **RESOLVED**: {resolution_comment}")
            
            # Close the issue
            cmd = ["gh", "issue", "close", str(issue_number), "--comment", "Issue resolved and validated"]
            subprocess.run(cmd, check=True)
            print(f"✅ Closed issue #{issue_number}")
        except subprocess.CalledProcessError:
            print(f"❌ Failed to close issue #{issue_number}")

def main():
    """CLI interface for Git issue automation"""
    if len(sys.argv) < 2:
        print("Usage: python git-issue-automation.py <command> [args...]")
        print("Commands:")
        print("  create-violation <type> <severity> <phase> <agent> <description>")
        print("  check-blockers")
        print("  validate-phase <phase>")
        print("  update-issue <number> <comment>")
        print("  close-issue <number> <resolution>")
        sys.exit(1)
    
    command = sys.argv[1]
    manager = SPARCGitIssueManager()
    
    if command == "create-violation":
        if len(sys.argv) < 7:
            print("Usage: create-violation <type> <severity> <phase> <agent> <description>")
            sys.exit(1)
        
        violation = FrameworkViolation(
            violation_type=sys.argv[2],
            severity=sys.argv[3],
            phase=sys.argv[4],
            agent=sys.argv[5],
            description=" ".join(sys.argv[6:])
        )
        
        manager.create_violation_issue(violation)
    
    elif command == "check-blockers":
        blockers = manager.check_open_blockers()
        if blockers:
            print(f"❌ {len(blockers)} blocking issues found:")
            for issue in blockers:
                print(f"   • Issue #{issue['number']}: {issue['title']}")
        else:
            print("✅ No blocking issues found")
    
    elif command == "validate-phase":
        if len(sys.argv) < 3:
            print("Usage: validate-phase <phase>")
            sys.exit(1)
        
        phase = sys.argv[2]
        if manager.validate_phase_completion(phase):
            print(f"✅ {phase} phase ready for completion")
        else:
            print(f"❌ {phase} phase blocked")
    
    elif command == "update-issue":
        if len(sys.argv) < 4:
            print("Usage: update-issue <number> <comment>")
            sys.exit(1)
        
        issue_number = int(sys.argv[2])
        comment = " ".join(sys.argv[3:])
        manager.update_issue_progress(issue_number, comment)
    
    elif command == "close-issue":
        if len(sys.argv) < 4:
            print("Usage: close-issue <number> <resolution>")
            sys.exit(1)
        
        issue_number = int(sys.argv[2])
        resolution = " ".join(sys.argv[3:])
        manager.close_resolved_issue(issue_number, resolution)
    
    else:
        print(f"Unknown command: {command}")
        sys.exit(1)

if __name__ == "__main__":
    main()